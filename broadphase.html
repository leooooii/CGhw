  <!DOCTYPE html>

    <html>
    
    <head>
    <style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

    </style>
    </head>

    <body> 
<div id="info">AABB Test
</div>
<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js"></script>



    <script>
javascript:(function(){var script=document.createElement('script');script.onload=function(){var stats=new Stats();document.body.appendChild(stats.dom);requestAnimationFrame(function loop(){stats.update();requestAnimationFrame(loop)});};script.src='//mrdoob.github.io/stats.js/build/stats.min.js';document.head.appendChild(script);})()

//var baardphase = [];

class broadphase{
  constructor(pointx,pointy,num){
  this.pointx=pointx;
  this.pointy=pointy
  this.num=num;
  this.isBeg=true;
  this.isEnd=false;
  }
   
}

class AABB {
  constructor(pos, vel, halfSize) {
    this.center = pos.clone();
    this.vel = vel.clone();
    this.halfSize = halfSize.clone();
    this.min = pos.clone().sub (this.halfSize);
    this.max = pos.clone().add (this.halfSize);
    this.box = new THREE.Mesh (new THREE.PlaneGeometry(this.halfSize.x * 2, this.halfSize.y * 2, 0), new THREE.MeshBasicMaterial());
    
    scene.add(this.box);
    this.box.position.copy(this.center);
  }
  update(dt) {
    this.center.add(this.vel.clone().multiplyScalar(dt));
    
    if (Math.abs(this.center.x) > 40-this.halfSize.x) this.vel.x *= -1;
    if (Math.abs(this.center.y) > 40-this.halfSize.y) this.vel.y *= -1;
    
    this.max.addVectors(this.center, this.halfSize);
    this.min.subVectors(this.center, this.halfSize);
    this.box.position.copy(this.center);
  }
  collide(other) {
    // boolean returning
    
    // x-axis
    if (Math.abs(this.center.x - other.center.x) >= this.halfSize.x + other.halfSize.x)
      return false;
    // y-axis
    if (Math.abs(this.center.y - other.center.y) >= this.halfSize.y + other.halfSize.y)
      return false;
   return true;
    
  }
}




var camera, scene, renderer;
var bbs = [];
var bp=[];
var collide=[];
init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer();

  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  scene = new THREE.Scene();
  camera = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 100);
  camera.position.z = 10;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(-40, -40, 0),
    new THREE.Vector3(40, -40, 0),
    new THREE.Vector3(40, 40, 0),
    new THREE.Vector3(-40, 40, 0),
    new THREE.Vector3(-40, -40, 0));

  var border = new THREE.Line(geometry, new THREE.LineBasicMaterial({
    color: 0x0000ff
  }));
  scene.add(border);

  window.addEventListener('resize', onWindowResize, false);

  /////////////////////////////////////////////////
  let speed = 5;
  let blocks = 2;
  for (var i = 0; i < blocks; i++)
  bbs.push ( new AABB(new THREE.Vector3(myRandom()*40,myRandom()*40,0), new THREE.Vector3(myRandom()*speed, myRandom()*speed,0), new THREE.Vector3(2, 1, 0)) );
  //console.log(bbs[0].halfSize)
  for (let i = 0; i < bbs.length; i++) 
{
  collide[i]=0;
}
  for (let i = 0; i < bbs.length; i++) 
{
  bp.push(new broadphase(bbs[i].min.x,bbs[i].min.y,i));
}
}

function myRandom () {  //[-1,1]
  return Math.random()*2-1;
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}


var temp;
var num1,num2;
function animate() {
  requestAnimationFrame(animate);
  render();
  


  for (let i = 0; i < bbs.length; i++) 
  {
    bbs[i].update(0.1);
    bp[i].pointx=bbs[i].min.x;
    bp[i].pointy=bbs[i].min.y;
    for(let j=1;j<bbs.length;j++){
       for(let x=j-1;x>=0;x--){
       if(bp[j].pointx<bp[x].pointx){
       temp=bp[j].num;
       bp[j].num=bp[x].num;
       bp[x].num=temp;
       num1=bp[j].num;
       num2=bp[x].num;
       bp[j].pointx=bbs[num1].min.x;
       bp[j].pointy=bbs[num1].min.y;
       bp[x].pointx=bbs[num2].min.x;
       bp[x].pointy=bbs[num2].min.y;
       }
       }
    }
    for(let j=1;j<bbs.length;j++){
     if(bp[i].pointx+4>bp[j].pointx){
        bbs[i].box.material.color.set ('red');
        bbs[j].box.material.color.set ('red');
     }
    else {
        bbs[i].box.material.color.set ('white');
        bbs[j].box.material.color.set ('white');
    }
    }
     
    
    
    
    
    
/*for (let j = i+1; j < bbs.length ; j++) 
  {    
      if (bbs[i].collide(bbs[j])) {
        bbs[i].box.material.color.set ('red');
        bbs[j].box.material.color.set ('red');
        collide[i] = 1;
        collide[j] = 1;
     }
      else if(collide[i]==0&&collide[j]==0) {
        bbs[i].box.material.color.set ('white');
        bbs[j].box.material.color.set ('white');
      }
    }
       collide[i] = 0;*/
    }
    
}

function render() {
  renderer.render(scene, camera);
}


        </script>
    </body>

    </html>